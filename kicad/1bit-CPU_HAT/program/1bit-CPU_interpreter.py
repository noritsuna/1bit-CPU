#!/usr/bin/env python3import gpiozeroimport signalimport timeimport sysCLK_OUT_PIN 	= gpiozero.DigitalOutputDevice(pin=13)CLK_IN_PIN 		= gpiozero.DigitalInputDevice(pin=12)REG_0_IN_PIN 	= gpiozero.DigitalInputDevice(pin=25)PC_0_IN_PIN 	= gpiozero.DigitalInputDevice(pin=23)PC_1_IN_PIN 	= gpiozero.DigitalInputDevice(pin=24)PROG_0_OUT_PIN 	= gpiozero.DigitalOutputDevice(pin=27)PROG_1_OUT_PIN 	= gpiozero.DigitalOutputDevice(pin=17)RESET_OUT_PIN 	= gpiozero.DigitalOutputDevice(pin=22)#命令	機械語	説明#ADD A, Im	0	AレジスタにIm（イミディエイトデータ）を加算する。#JMP Im	1	Imで指定した先の番地へジャンプする。#Loop Add A+1#ADD A, 1#JMP 0#1 time Add A+1#ADD A, 1#JMP 1#NOP#JMP 0PC		= 0PC_0	= 0PC_1	= 0REG_0	= 0PROG_0	= 0PROG_1	= 0CLK_IN	= 0CLK_DIV	= 1CLK_Hz	= 1.0OP_TIME = 2.0CLK_STATE= 0MEM_PC = []REG_A = 0def contVCO_Hz():	counter = 1	CLK_state = 0	cur_state = 0	clk_timer = 0.0	start_time = time.time()	while time.time() - start_time < OP_TIME:		cur_state = CLK_IN_PIN.value		if CLK_state != cur_state:			if cur_state == 1:				counter = counter + 1				CLK_state = 1			else:				CLK_state = 0	CLK_Hz = float(counter)	print("CLK_Hz=" + str(CLK_Hz))	return CLK_Hzdef waittimer(wait_clk):	counter = 1	CLK_state = 0	cur_state = 0	while counter < wait_clk:		cur_state = CLK_IN_PIN.value		if CLK_state != cur_state:			if cur_state == 1:				counter = counter + 1				CLK_state = 1			else:				CLK_state = 0def parseCMD(mem, pc):	cmd_line = mem[pc]	cmd_list = cmd_line.upper().split()	if cmd_list[0] == "ADD":		del_comma = cmd_list[1].split(',')		cmd_list[1] = del_comma[0]		if cmd_list[1] != "A":			print("Error: Non Support mnemonic..")			sys.exit(1)		if cmd_list[2].isdigit():			if 0 != int(cmd_list[2]) and 1 != int(cmd_list[2]):				print("Error: Non Support mnemonic..")				sys.exit(1)		else:			print("Error: Non Support mnemonic..")			sys.exit(1)	elif cmd_list[0] == "JMP":		if cmd_list[1].isdigit():			reg_num = int(cmd_list[1])			if 0 != reg_num and 1 != reg_num:				print("Error: Non Support mnemonic..")				sys.exit(1)			if (reg_num + 1) > len(mem):				print("Error: Non Support mnemonic..")				sys.exit(1)		else:			print("Error: Non Support mnemonic..")			sys.exit(1)	else:		print("Error: Non Support mnemonic..")		sys.exit(1)	return cmd_listtry:	args = sys.argv	if 1 == len(args):		print("Usage: 1bit-CPU_interpreter [your program file path] [Option: Operating Speed[s]].")		sys.exit(1)	elif 2 == len(args) or 3 == len(args):		with open(args[1]) as f:			for s_line in f:				MEM_PC.append(s_line)				print(repr(s_line))		if 0 == len(MEM_PC):			print("Error: Program Read Error.")			sys.exit(1)		if 3 == len(args):			if args[2].isfloat():				OP_TIME	= float(args[2])			else:				print("Error: Argument(clock division) is not digit.")				sys.exit(1)	else:		print("Error: Too Many Args.")		sys.exit(1)	RESET_OUT_PIN.on()	time.sleep(0.1)	RESET_OUT_PIN.off()	CLK_Hz = contVCO_Hz()	PROG_0_OUT_PIN.off()	PROG_1_OUT_PIN.on()	time.sleep(0.1)	REG_A = 0	PC = 0	while True:		if CLK_STATE == 1:			CLK_OUT_PIN.on();			REG_0	= REG_0_IN_PIN.value			REG_A	= REG_0			REG_A_R = REG_0			PC_0	= PC_0_IN_PIN.value			PC_1	= PC_1_IN_PIN.value			cmd_list = parseCMD(MEM_PC, PC)			if cmd_list[0] == "ADD":				REG_A = REG_A + int(cmd_list[2])				if REG_A >= 2:					REG_A = 0				REG_A_R = REG_A				REG_A_R	= REG_A_R + 1				if REG_A_R >= 2:					REG_A_R = 0				PROG_0_OUT_PIN.off()				PROG_1_OUT_PIN.on()				PC = PC + 1				if PC >= 2:					PC = 0			elif cmd_list[0] == "JMP":				PC = int(cmd_list[1])				if REG_A == 1 and PC == 1:					PROG_0_OUT_PIN.on()					PROG_1_OUT_PIN.off()				elif REG_A == 0 and PC == 0:					PROG_0_OUT_PIN.on()					PROG_1_OUT_PIN.off()				else:					PROG_0_OUT_PIN.on()					PROG_1_OUT_PIN.off()			else:				print("NOP")			print("CMD=" + cmd_list[0] + ", nextPC=" + str(PC) + ", REG_A=" + str(REG_A_R) + ", REG_0=" + str(REG_0) + ", PC_0=" + str(PC_0) + ", PC_1=" + str(PC_1))			CLK_STATE = 0			waittimer(CLK_Hz/2.0)		else:			CLK_OUT_PIN.off()			CLK_STATE = 1			waittimer(CLK_Hz/2.0)finally:	CLK_OUT_PIN.close()	CLK_IN_PIN.close()	REG_0_IN_PIN.close()	PC_0_IN_PIN.close()	PC_1_IN_PIN.close()	PROG_0_OUT_PIN.close()	PROG_1_OUT_PIN.close()	RESET_OUT_PIN.close()